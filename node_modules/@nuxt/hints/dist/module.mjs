import { addDevServerHandler, defineNuxtModule, createResolver, addComponent, addPlugin, addBuildPlugin, addServerHandler, addServerPlugin } from '@nuxt/kit';
import { HYDRATION_ROUTE, HYDRATION_SSE_ROUTE } from '../dist/runtime/hydration/utils.js';
import { existsSync } from 'node:fs';
import { eventHandler, proxyRequest } from 'h3';
import { genImport } from 'knitwork';
import MagicString from 'magic-string';
import { dirname, resolve } from 'node:path';
import { parseSync } from 'oxc-parser';
import { createUnplugin } from 'unplugin';
import { fileURLToPath } from 'node:url';

const DEVTOOLS_UI_ROUTE = "/__nuxt-hints";
const DEVTOOLS_UI_LOCAL_PORT = 3300;
function setupDevToolsUI(nuxt, resolver) {
  const clientPath = resolver.resolve("./client");
  const isProductionBuild = existsSync(clientPath);
  if (isProductionBuild) {
    nuxt.hook("vite:serverCreated", async (server) => {
      const sirv = await import('sirv').then((r) => r.default || r);
      server.middlewares.use(
        DEVTOOLS_UI_ROUTE,
        sirv(clientPath, { dev: true, single: true })
      );
    });
  } else {
    addDevServerHandler({
      route: DEVTOOLS_UI_ROUTE,
      handler: eventHandler((e) => {
        return proxyRequest(e, "http://localhost:" + DEVTOOLS_UI_LOCAL_PORT + DEVTOOLS_UI_ROUTE + e.path);
      })
    });
  }
  nuxt.hook("devtools:customTabs", (tabs) => {
    tabs.push({
      name: "hints",
      title: "Hints",
      icon: "carbon:idea",
      category: "analyze",
      view: {
        type: "iframe",
        src: DEVTOOLS_UI_ROUTE
      }
    });
  });
}

const distDir = dirname(fileURLToPath(import.meta.url));

const INCLUDE_VUE_RE = /\.vue$/;
const EXCLUDE_NODE_MODULES = /node_modules/;
const DEFINE_COMPONENT_RE = /defineComponent/;
const DEFINE_NUXT_COMPONENT_RE = /defineNuxtComponent/;
const skipPath = normalizePath(resolve(distDir, "runtime/hydration/component.ts"));
const InjectHydrationPlugin = createUnplugin(() => {
  return [
    {
      name: "@nuxt/hints:modify-hydration-composable-import",
      enforce: "post",
      transform: {
        filter: {
          id: {
            include: /.(vue|ts|js|tsx|jsx)$/,
            exclude: [skipPath, EXCLUDE_NODE_MODULES]
          },
          code: {
            include: [DEFINE_COMPONENT_RE, DEFINE_NUXT_COMPONENT_RE]
          }
        },
        async handler(code, id) {
          const m = new MagicString(code);
          const { program } = parseSync(id, code);
          const imports = program.body.filter((node) => node.type === "ImportDeclaration");
          const hasDefineComponent = DEFINE_COMPONENT_RE.test(code);
          const hasDefineNuxtComponent = DEFINE_NUXT_COMPONENT_RE.test(code);
          const defineComponentImport = findImportSpecifier(
            imports,
            "defineComponent",
            ["vue", "#imports"],
            (specifier, nextSpecifier) => {
              m.remove(
                specifier.start,
                nextSpecifier?.start ?? specifier.end
              );
            }
          );
          const defineComponentAlias = defineComponentImport?.local.name || "defineComponent";
          const defineNuxtComponentImport = findImportSpecifier(
            imports,
            "defineNuxtComponent",
            ["#app/composables/component", "#imports", "#app", "nuxt/app"],
            (specifier, next) => {
              m.remove(
                specifier.start,
                next?.start ?? specifier.end
              );
            }
          );
          const defineNuxtComponentAlias = defineNuxtComponentImport?.local.name || "defineNuxtComponent";
          const importsToAdd = new Set([
            hasDefineComponent && genImport(
              "@nuxt/hints/runtime/hydration/component",
              [defineComponentAlias === "defineComponent" ? "defineComponent" : { name: "defineComponent", as: defineComponentAlias }]
            ),
            hasDefineNuxtComponent && genImport(
              "@nuxt/hints/runtime/hydration/component",
              [defineNuxtComponentAlias === "defineNuxtComponent" ? "defineNuxtComponent" : { name: "defineNuxtComponent", as: defineNuxtComponentAlias }]
            )
          ].filter(Boolean));
          m.prepend([...importsToAdd].join("\n") + "\n");
          if (m.hasChanged()) {
            return {
              code: m.toString(),
              map: m.generateMap({ hires: true })
            };
          }
        }
      }
    },
    {
      name: "@nuxt/hints:inject-hydration-composable",
      enforce: "post",
      transform: {
        filter: {
          id: {
            include: INCLUDE_VUE_RE,
            exclude: [skipPath, EXCLUDE_NODE_MODULES]
          },
          code: {
            exclude: [DEFINE_COMPONENT_RE, DEFINE_NUXT_COMPONENT_RE]
          }
        },
        handler(code, id) {
          const m = new MagicString(code);
          const { program } = parseSync(id, code);
          const exportDeclaration = program.body.find(
            (node) => node.type === "ExportDefaultDeclaration"
          )?.declaration;
          if (exportDeclaration) {
            m.prepend(genImport(
              "@nuxt/hints/runtime/hydration/component",
              ["defineComponent"]
            ));
            m.overwrite(
              exportDeclaration.start,
              exportDeclaration.end,
              `defineComponent(${code.slice(exportDeclaration.start, exportDeclaration.end)})`
            );
          }
          if (m.hasChanged()) {
            return {
              code: m.toString(),
              map: m.generateMap({ hires: true })
            };
          }
        }
      }
    }
  ];
});
function findImportSpecifier(importDecl, importedName, pkgNames, callback) {
  const names = Array.isArray(pkgNames) ? pkgNames : [pkgNames];
  const allSpecifiers = importDecl.filter((imp) => names.includes(imp.source.value)).flatMap((decl) => decl.specifiers.map((spec, i) => ({ spec, next: decl.specifiers[i + 1] })));
  const match = allSpecifiers.find(
    ({ spec }) => spec.type === "ImportSpecifier" && spec.imported.type === "Identifier" && spec.imported.name === importedName
  );
  if (match) {
    callback?.(match.spec, match.next);
    return match.spec;
  }
}
function normalizePath(path) {
  return path.replace(/\\/g, "/");
}

const moduleName = "@nuxt/hints";
const module$1 = defineNuxtModule({
  meta: {
    name: moduleName,
    configKey: "hints"
  },
  defaults: {
    devtools: true
  },
  setup(options, nuxt) {
    if (!nuxt.options.dev) {
      return;
    }
    nuxt.options.nitro.experimental = nuxt.options.nitro.experimental || {};
    nuxt.options.nitro.experimental.websocket = true;
    const resolver = createResolver(import.meta.url);
    addComponent({
      name: "NuxtIsland",
      filePath: resolver.resolve("./runtime/core/components/nuxt-island"),
      priority: 1e3
    });
    addPlugin(resolver.resolve("./runtime/web-vitals/plugin.client"));
    addPlugin(resolver.resolve("./runtime/hydration/plugin.client"));
    addBuildPlugin(InjectHydrationPlugin);
    addServerHandler({
      route: HYDRATION_ROUTE,
      handler: resolver.resolve("./runtime/hydration/handler.nitro")
    });
    addServerHandler({
      route: HYDRATION_SSE_ROUTE,
      handler: resolver.resolve("./runtime/hydration/sse.nitro")
    });
    addPlugin(resolver.resolve("./runtime/third-party-scripts/plugin.client"));
    addServerPlugin(resolver.resolve("./runtime/third-party-scripts/nitro.plugin"));
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({
        types: resolver.resolve("./runtime/types.d.ts")
      });
    });
    if (options.devtools) {
      setupDevToolsUI(nuxt, resolver);
      addPlugin(resolver.resolve("./runtime/core/plugins/vue-tracer-state.client"));
    }
    nuxt.options.build.transpile.push(moduleName);
  }
});

export { module$1 as default };
